//
//  DIManager.swift
//  DungeonStride
//

import Foundation

final class DIContainer {
    typealias Resolver = () -> Any
    
    private var resolvers = [String: Resolver]()
    private var cache = [String: Any]()
    
    static let shared = DIContainer()
    
    init() {
        registerDependencies()
    }
    
    func register<T, R>(_ type: T.Type, cached: Bool = false, service: @escaping () -> R) {
        let key = String(reflecting: type)
        resolvers[key] = service
        
        if cached {
            cache[key] = service()
        }
    }
    
    func resolve<T>() -> T {
        let key = String(reflecting: T.self)
        
        if let cachedService = cache[key] as? T {
            return cachedService
        }
        
        if let resolver = resolvers[key], let service = resolver() as? T {
            return service
        }
        
        fatalError("ü•£ \(key) has not been registered.")
    }
}

extension DIContainer {
    func registerDependencies() {
        // 1. Activity Manager
        register(ActivityManager.self, cached: true) {
            ActivityManager()
        }
        
        // 2. Haptic Manager (Singleton)
        register(HapticManager.self, cached: true) {
            HapticManager.shared
        }
        
        // 3. Location Manager
        // Registrujeme ho, kdybychom ho pot≈ôebovali injectnout jinam ne≈æ do ActivityManageru
        register(LocationManager.self, cached: true) {
            LocationManager()
        }
        
        // Pozn√°mka: Ostatn√≠ slu≈æby jako UserService, AuthViewModel, ThemeManager
        // jsou v t√©to architektu≈ôe inicializov√°ny v App jako @StateObject a p≈ôed√°v√°ny
        // p≈ôes .environmentObject, co≈æ je pro SwiftUI ViewModels spr√°vnƒõ.
        // Pokud bys je chtƒõl m√≠t zde, museli bychom zmƒõnit inicializaci v DungeonStrideApp.swift.
    }
}
